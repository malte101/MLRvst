// Auto-generated by generate_halfband_coeffs.py
// Do not edit manually

#pragma once

#ifndef OVERSAMPLING_FILTER_COEFFS_HPP
#define OVERSAMPLING_FILTER_COEFFS_HPP

#include <array>
#include <cmath>
#include <cstdint>

namespace MoogLadders {
namespace Oversampling {

// Allpass section coefficient storage
struct AllpassCoeff {
    int order;          // 1 = first order, 2 = second order
    double a1;          // First coefficient
    double a2;          // Second coefficient (only for order=2)
};

// Half-band filter coefficients in polyphase allpass form
struct HalfBandCoeffs {
    const AllpassCoeff* branch0;  // Even samples allpass chain
    uint32_t branch0_count;
    const AllpassCoeff* branch1;  // Odd samples allpass chain
    uint32_t branch1_count;
    int latency_samples;          // Filter latency in samples
};

enum class Quality {
    Draft,     // ~40dB stopband, low CPU
    Standard,  // ~60dB stopband, balanced
    High       // ~80dB stopband, highest quality
};

enum class PhaseMode {
    MinimumPhase,     // Lower latency, phase distortion
    QuasiLinearPhase  // Higher latency, flatter phase
};

// Draft quality - MinimumPhase - Branch 0
static const AllpassCoeff kHalfBand_Draft_MinPhase_Branch0[] = {
    {1, 0.1176470588235294, 0.0},
};

// Draft quality - MinimumPhase - Branch 1
static const AllpassCoeff kHalfBand_Draft_MinPhase_Branch1[] = {
    {2, 0.5352980861116968, 0.0402889934041344},
};

// Draft quality - QuasiLinearPhase - Branch 0
static const AllpassCoeff kHalfBand_Draft_QuasiLinear_Branch0[] = {
    {1, 0.0000000000000000, 0.0},
    {1, 0.1176470588235294, 0.0},
};

// Draft quality - QuasiLinearPhase - Branch 1
static const AllpassCoeff kHalfBand_Draft_QuasiLinear_Branch1[] = {
    {1, 0.0000000000000000, 0.0},
    {2, 0.5352980861116968, 0.0402889934041344},
};

// Standard quality - MinimumPhase - Branch 0
static const AllpassCoeff kHalfBand_Standard_MinPhase_Branch0[] = {
    {1, 0.0636044237126984, 0.0},
    {2, 0.5120527193695535, 0.0185681196357082},
};

// Standard quality - MinimumPhase - Branch 1
static const AllpassCoeff kHalfBand_Standard_MinPhase_Branch1[] = {
    {2, 0.2699424601713852, 0.0018523256018694},
};

// Standard quality - QuasiLinearPhase - Branch 0
static const AllpassCoeff kHalfBand_Standard_QuasiLinear_Branch0[] = {
    {1, 0.0000000000000000, 0.0},
    {1, 0.0636044237126984, 0.0},
    {2, 0.5120527193695535, 0.0185681196357082},
};

// Standard quality - QuasiLinearPhase - Branch 1
static const AllpassCoeff kHalfBand_Standard_QuasiLinear_Branch1[] = {
    {1, 0.0000000000000000, 0.0},
    {2, 0.2699424601713852, 0.0018523256018694},
};

// High quality - MinimumPhase - Branch 0
static const AllpassCoeff kHalfBand_High_MinPhase_Branch0[] = {
    {1, 0.0361328125000000, 0.0},
    {2, 0.3883457569587482, 0.0078125000000000},
};

// High quality - MinimumPhase - Branch 1
static const AllpassCoeff kHalfBand_High_MinPhase_Branch1[] = {
    {2, 0.1467429045417735, 0.0009765625000000},
    {2, 0.5869511310896879, 0.0361328125000000},
};

// High quality - QuasiLinearPhase - Branch 0
static const AllpassCoeff kHalfBand_High_QuasiLinear_Branch0[] = {
    {1, 0.0000000000000000, 0.0},
    {1, 0.0361328125000000, 0.0},
    {2, 0.3883457569587482, 0.0078125000000000},
};

// High quality - QuasiLinearPhase - Branch 1
static const AllpassCoeff kHalfBand_High_QuasiLinear_Branch1[] = {
    {1, 0.0000000000000000, 0.0},
    {2, 0.1467429045417735, 0.0009765625000000},
    {2, 0.5869511310896879, 0.0361328125000000},
};

// Latency lookup tables (samples at input rate)
// MinimumPhase latency per 2x stage
static const int kLatencyMinPhase[] = {
    2,  // Draft: 3rd order
    3,  // Standard: 5th order
    4   // High: 7th order
};

// QuasiLinearPhase latency per 2x stage
static const int kLatencyLinearPhase[] = {
    4,  // Draft: 3rd order (min + 2)
    5,  // Standard: 5th order (min + 2)
    6   // High: 7th order (min + 2)
};

// Get coefficients for specified quality
inline HalfBandCoeffs GetHalfBandCoeffs(Quality quality, PhaseMode phase) {
    HalfBandCoeffs result;
    int qualityIdx = static_cast<int>(quality);
    
    switch (quality) {
        case Quality::Draft:
            if (phase == PhaseMode::MinimumPhase) {
                result.branch0 = kHalfBand_Draft_MinPhase_Branch0;
                result.branch0_count = sizeof(kHalfBand_Draft_MinPhase_Branch0) / sizeof(AllpassCoeff);
                result.branch1 = kHalfBand_Draft_MinPhase_Branch1;
                result.branch1_count = sizeof(kHalfBand_Draft_MinPhase_Branch1) / sizeof(AllpassCoeff);
            } else {
                result.branch0 = kHalfBand_Draft_QuasiLinear_Branch0;
                result.branch0_count = sizeof(kHalfBand_Draft_QuasiLinear_Branch0) / sizeof(AllpassCoeff);
                result.branch1 = kHalfBand_Draft_QuasiLinear_Branch1;
                result.branch1_count = sizeof(kHalfBand_Draft_QuasiLinear_Branch1) / sizeof(AllpassCoeff);
            }
            break;
        case Quality::Standard:
            if (phase == PhaseMode::MinimumPhase) {
                result.branch0 = kHalfBand_Standard_MinPhase_Branch0;
                result.branch0_count = sizeof(kHalfBand_Standard_MinPhase_Branch0) / sizeof(AllpassCoeff);
                result.branch1 = kHalfBand_Standard_MinPhase_Branch1;
                result.branch1_count = sizeof(kHalfBand_Standard_MinPhase_Branch1) / sizeof(AllpassCoeff);
            } else {
                result.branch0 = kHalfBand_Standard_QuasiLinear_Branch0;
                result.branch0_count = sizeof(kHalfBand_Standard_QuasiLinear_Branch0) / sizeof(AllpassCoeff);
                result.branch1 = kHalfBand_Standard_QuasiLinear_Branch1;
                result.branch1_count = sizeof(kHalfBand_Standard_QuasiLinear_Branch1) / sizeof(AllpassCoeff);
            }
            break;
        case Quality::High:
            if (phase == PhaseMode::MinimumPhase) {
                result.branch0 = kHalfBand_High_MinPhase_Branch0;
                result.branch0_count = sizeof(kHalfBand_High_MinPhase_Branch0) / sizeof(AllpassCoeff);
                result.branch1 = kHalfBand_High_MinPhase_Branch1;
                result.branch1_count = sizeof(kHalfBand_High_MinPhase_Branch1) / sizeof(AllpassCoeff);
            } else {
                result.branch0 = kHalfBand_High_QuasiLinear_Branch0;
                result.branch0_count = sizeof(kHalfBand_High_QuasiLinear_Branch0) / sizeof(AllpassCoeff);
                result.branch1 = kHalfBand_High_QuasiLinear_Branch1;
                result.branch1_count = sizeof(kHalfBand_High_QuasiLinear_Branch1) / sizeof(AllpassCoeff);
            }
            break;
    }
    
    if (phase == PhaseMode::MinimumPhase) {
        result.latency_samples = kLatencyMinPhase[qualityIdx];
    } else {
        result.latency_samples = kLatencyLinearPhase[qualityIdx];
    }
    
    return result;
}

// Calculate total latency for oversampling factor
inline int GetTotalLatency(int factor, Quality quality, PhaseMode phase) {
    int qualityIdx = static_cast<int>(quality);
    int perStageLatency = (phase == PhaseMode::MinimumPhase)
        ? kLatencyMinPhase[qualityIdx]
        : kLatencyLinearPhase[qualityIdx];
    
    // Number of stages: log2(factor)
    int numStages = 0;
    int f = factor;
    while (f > 1) { numStages++; f >>= 1; }
    
    // Each stage adds latency, but at different rates
    // Stage 1: latency at input rate
    // Stage 2: latency/2 at input rate (runs at 2x)
    // Stage 3: latency/4 at input rate (runs at 4x)
    double totalLatency = 0.0;
    int divisor = 1;
    for (int i = 0; i < numStages; i++) {
        // Upsampler latency
        totalLatency += static_cast<double>(perStageLatency) / divisor;
        // Downsampler latency (same as upsampler for symmetric filter)
        totalLatency += static_cast<double>(perStageLatency) / divisor;
        divisor *= 2;
    }
    
    return static_cast<int>(std::lround(totalLatency));
}

} // namespace Oversampling
} // namespace MoogLadders

#endif // OVERSAMPLING_FILTER_COEFFS_HPP
